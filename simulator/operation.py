# business_model_simulator/simulator/operation.py

class Operation:
    """
    Represents an individual business activity in the simulation.
    This base class may be extended or overridden for specific cost/revenue
    calculations or contract complexity models.
    """

    def __init__(self, name, parameters=None, contract_complexity=None):
        """
        :param name: str, identifier for the operation
        :param parameters: dict, key-value pairs for operation-specific parameters
            Example parameters might include:
              - direct_cost: float, base cost per operation
              - variable_cost: float, cost that scales with volume
              - transaction_volume: float or int, used in cost/revenue calculations
              - base_revenue: float, flat revenue
              - revenue_per_unit: float, revenue per transaction unit
        :param contract_complexity: an optional complexity indicator (e.g. 'High', 'Medium', 'Low')
            that may be used in cost calculations.
        """
        self.name = name
        self.parameters = parameters if parameters else {}
        self.contract_complexity = contract_complexity

        # Example mapping of complexity levels to cost multipliers;
        # can be extended or replaced by subclasses.
        self._complexity_multipliers = {
            'High': 2.0,
            'Medium': 1.5,
            'Low': 1.0
        }

    def compute_cost(self):
        """
        Returns the total cost of this operation.
        
        This base implementation uses a simple formula:
          total_cost = (direct_cost + variable_part) * complexity_multiplier
          
        Subclasses can override this method to handle custom logic.
        """
        direct_cost = self.parameters.get('direct_cost', 0.0)
        variable_cost = self.parameters.get('variable_cost', 0.0)
        volume = self.parameters.get('transaction_volume', 1.0)

        complexity_multiplier = self._complexity_multipliers.get(
            self.contract_complexity, 
            1.0
        )
        variable_part = variable_cost * volume
        total_cost = (direct_cost + variable_part) * complexity_multiplier

        return total_cost

    def compute_revenue(self):
        """
        Returns the revenue generated by this operation.
        
        This base implementation uses a simple formula:
          total_revenue = base_revenue + (revenue_per_unit * transaction_volume)
          
        Subclasses can override this method to handle custom logic.
        """
        base_revenue = self.parameters.get('base_revenue', 0.0)
        revenue_per_unit = self.parameters.get('revenue_per_unit', 0.0)
        volume = self.parameters.get('transaction_volume', 1.0)

        total_revenue = base_revenue + (revenue_per_unit * volume)
        return total_revenue
